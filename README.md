Бэкдоры  

В этом репозитории реализовано 4 бэкдора
2 ранцевой криптосистемы и 2 rsa

усовершентсвованный rsa лежит в файле rsa.py  

Усоврешенствованный ранцевый бэкод находиться в файле knapsack_plus.py  

усовершенствования заключаються в следующем:
реализованы дополнительные методы улучшения, такие как:
 • Генетический алгоритм для оптимизации параметров,
 • Хаотические последовательности для добавления “шума”,
 • Преобразование приватного ключа через матрицу проекции.

методы расшифровки и поиска секретного ключа по открытому еще в процессе  

Процесс работы криптосистемы с бэкдором

 1. Генерация ключей:
 • Создаётся приватный ключ (супервозрастающая последовательность).
 • Оптимизируются параметры модуля и множителя.
 • Генерируется публичный ключ с добавлением шума.
 2. Шифрование:
 • Сообщение конвертируется в бинарный вид.
 • Каждый бит умножается на соответствующий элемент публичного ключа.
 • Результаты суммируются, образуя шифротекст.
 3. Расшифровка:
 • Приватный ключ используется для восстановления бинарного сообщения из шифротекста.
 4. Работа бэкдора:
 • Параметры бэкдора позволяют восстановить приватный ключ, используя публичный ключ.

Описание knapsack_plus:  
основная функция для генерации бэкдора - generate_hybrid_keys
она принимает в себя bit_lenght - длинну сообщения умноженную на 8 (переводит в биты)

population_size - определяет размер популяции, то есть количество потенциальных решений, которые генетический алгоритм будет обрабатывать на каждом шаге

generations -указывает количество поколений или итераций, за которые генетический алгоритм будет эволюционировать популяцию

Первым шагом создаем супервозрастающюю последовательность благодря функции generate_superincreasing_sequence она принимает длиннус троки в битах

После чего запускаем алгоритм для оптимизации параметров или генетический алгоритм genetic_algorithm_optimize
Генетический алгоритм моделирует процесс эволюции, используя идеи из биологии: естественный отбор, скрещивание и мутации.
population_size - Размер популяции, то есть количество возможных решений (особей), которые генетический алгоритм будет оценивать на каждом шаге.
 • Каждое решение представляет собой словарь с параметрами:
 • modulus: Значение на основе суммы всех элементов приватного ключа с добавлением случайного числа.
 • multiplier: Случайное число от 2 до 100.

Функция fitness определяет “качество” особи (насколько хорошо её параметры решают задачу):

 1. Проверяет, что multiplier и modulus взаимно просты (gcd(multiplier, modulus) == 1).
 2. Генерирует публичный ключ из приватного ключа с использованием multiplier и modulus.
 3. Восстанавливает приватный ключ с помощью обратного множителя inverse_multiplier
 4. Сравнивает восстановленный ключ с оригинальным приватным ключом и подсчитывает количество совпадений.
Чем больше совпадений, тем лучше решение.

generations: Количество поколений (итераций), в течение которых популяция будет улучшаться.
Отбор лучших: Популяция сортируется по значению функции fitness. Половина лучших особей отбирается для следующего шага. после чего для создания новых решений (потомков) берутся две родительские особи из лучших. Потомок наследует усреднённые значения modulus и multiplier родителей и с небольшой вероятностью (10% или 0.1) параметры потомка немного изменяются случайным образом. Это помогает избежать “застревания” в локальном оптимуме

После завершения всех поколений возвращается лучшее решение из текущей популяции

inverse_multiplier - Обратный множитель, который позволяет “отменить” преобразование публичного ключа и восстановить приватный ключ

Эти параметры используются для “скрытия” приватного ключа, чтобы получить публичный ключ, который сложно проанализировать

Функция chaotic_sequence создаёт хаотическую последовательность чисел длиной bit_length -используется логистическое отображение для получения случайных чисел. Значения масштабируются на  10^6 , чтобы использоваться как добавочный шум. Это добавит “шум” к публичному ключу, усложняя его анализ.

Генерируется случайная матрица проекции размера bit_length x bit_length.
Приватный ключ (вектор) преобразуется в новое пространство с использованием матричного умножения
что маскирует его структуру, добавляя дополнительную сложность для анализа публичного ключа.

Публичный ключ генерируется из преобразованного приватного ключа путем умноения проекции на multiplier, добавления шума и остатка по модулю. Тем самым “запутывает” связь между публичным и приватным ключами.

Описание остальных бэкдоров находиться в их коде.
